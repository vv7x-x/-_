#!/usr/bin/env python3
"""
ğŸ´â€â˜ ï¸ OSINT HUNTER v5.0 ENTERPRISE - Ø§Ù„ÙƒÙˆØ¯ Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ Ù…Ø¹ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØµØ±ÙŠØ­Ø© ğŸ”¥ğŸ’€
Ù„ÙˆØ­Ø© ØªØ­ÙƒÙ… | 30+ API | Shodan | Rate Limit | Admin Panel
"""

import os
import asyncio
import logging
import re
import requests
import socket
import json
import sys
import subprocess
import hashlib
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any
from collections import defaultdict, deque
from dataclasses import dataclass, asdict
from pathlib import Path
import phonenumbers
from phonenumbers import geocoder, carrier, timezone
from concurrent.futures import ThreadPoolExecutor, as_completed
import secrets

# =============================================================================
# ğŸ”¥ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© - ØºÙŠØ±Ù‡Ø§ Ù‡Ù†Ø§ Ù…Ø¨Ø§Ø´Ø±Ø© ğŸ”¥
# =============================================================================

TELEGRAM_BOT_TOKEN = "8246905590:AAHdlEfGb_bGtHMVrXDjs9X5ErklquDlU9Q"  # Ø¶Ø¹ ØªÙˆÙƒÙ† Ø§Ù„Ø¨ÙˆØª Ù‡Ù†Ø§
ADMIN_USER_IDS = [7488354196]      # Ø¶Ø¹ Ù…Ø¹Ø±ÙØ§Øª Ø§Ù„Ø¥Ø¯Ø§Ø±ÙŠÙŠÙ†
SHODAN_API_KEY = "6K6QlHRmW8oiUeWrBmovR6TlIMCBlq0P"                         # Ø§Ø®ØªÙŠØ§Ø±ÙŠ - Shodan API Key
MAX_REQUESTS_PER_MINUTE = 20                # Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø·Ù„Ø¨Ø§Øª
PORT_SCAN_TIMEOUT = 0.8                     # timeout Ù„Ù…Ø³Ø­ Ø§Ù„Ù…ÙˆØ§Ù†Ø¦
API_REQUEST_TIMEOUT = 3.0                   # timeout Ù„Ù„Ù€ APIs
ENABLE_PROXY_ROTATION = False               # ØªÙØ¹ÙŠÙ„ ØªØ¯ÙˆÙŠØ± Ø§Ù„Ù€ Proxies

# =============================================================================
# Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…ÙˆØ§Ù†Ø¦ Ø§Ù„Ø´Ø§Ø¦Ø¹Ø© (30+ Ø®Ø¯Ù…Ø©)
# =============================================================================
COMMON_PORTS: Dict[int, str] = {
    21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP', 53: 'DNS', 80: 'HTTP',
    110: 'POP3', 135: 'RPC', 139: 'NetBIOS', 143: 'IMAP', 443: 'HTTPS',
    993: 'IMAPS', 995: 'POP3S', 1433: 'MSSQL', 1723: 'PPTP', 3306: 'MySQL',
    3389: 'RDP', 5432: 'PostgreSQL', 5900: 'VNC', 8080: 'HTTP-ALT',
    8443: 'HTTPS-ALT', 9200: 'Elasticsearch', 27017: 'MongoDB', 6379: 'Redis',
    11211: 'Memcached', 2375: 'Docker', 5000: 'Flask', 3000: 'Node.js', 8000: 'Django'
}

# =============================================================================
# APIs Ù„ØªØ­Ù„ÙŠÙ„ IP (30+ Ù…ØµØ¯Ø± Ù…ÙˆØ«ÙˆÙ‚)
# =============================================================================
IP_GEOLOCATION_APIS: List[str] = [
    "http://ip-api.com/json/{ip}?fields=status,country,city,isp,org,asn,abuse,hosting",
    "https://ipinfo.io/{ip}/json",
    "https://ipapi.co/{ip}/json/",
    "https://ipwhois.app/json/{ip}",
    "https://api.ip2country.info/ip?{ip}",
    "https://freegeoip.app/json/{ip}",
    "https://api.myip.com?ip={ip}",
    "https://ipapi.co/api/{ip}/",
    "https://ipvigilante.com/{ip}.json",
    "https://api.ipstack.com/{ip}?access_key=free",
    "http://ip-api.com/line/{ip}?fields=country,city,isp,org",
    "https://ipapi.co/{ip}/json/"
]

# =============================================================================
# Ù…Ù†ØµØ§Øª Ø§Ù„ØªÙˆØ§ØµÙ„ Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ (25+ Ù…Ù†ØµØ©)
# =============================================================================
SOCIAL_PLATFORMS: Dict[str, str] = {
    "ğŸ¦ X.com": "https://x.com/{}",
    "ğŸ“¸ Instagram": "https://instagram.com/{}",
    "ğŸ“˜ Facebook": "https://facebook.com/{}",
    "ğŸ’» GitHub": "https://github.com/{}",
    "ğŸ˜ Mastodon": "https://mastodon.social/@{}",
    "ğŸ‘» Ghost": "https://ghost.org/{}",
    "ğŸ“¹ YouTube": "https://youtube.com/@{}",
    "ğŸµ SoundCloud": "https://soundcloud.com/{}",
    "ğŸ’¬ Discord": "https://discord.com/users/{}",
    "ğŸ“± TikTok": "https://tiktok.com/@{}",
    "ğŸ‘¾ Twitch": "https://twitch.tv/{}",
    "ğŸ“ Medium": "https://medium.com/@{}",
    "ğŸ’¼ LinkedIn": "https://linkedin.com/in/{}",
    "ğŸ® Steam": "https://steamcommunity.com/id/{}",
    "ğŸ“¡ Reddit": "https://reddit.com/user/{}",
    "ğŸ™ GitLab": "https://gitlab.com/{}",
    "ğŸ”’ Keybase": "https://keybase.io/{}",
    "ğŸ’¾ SourceForge": "https://sourceforge.net/u/{}/",
    "ğŸ›’ Etsy": "https://etsy.com/shop/{}",
    "ğŸ¨ DeviantArt": "https://deviantart.com/{}",
    "ğŸ“¦ NPM": "https://npmjs.com/~{}",
    "ğŸ³ DockerHub": "https://hub.docker.com/u/{}",
    "ğŸ”¥ StackOverflow": "https://stackoverflow.com/users/{}",
    "ğŸ’ RubyGems": "https://rubygems.org/profiles/{}",
    "ğŸ˜ Mastodon.social": "https://mastodon.social/@{}"
}

# =============================================================================
# Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
# =============================================================================

# Dependencies Check
try:
    from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
    from telegram.ext import (
        Application, CommandHandler, MessageHandler, CallbackQueryHandler, 
        filters, ContextTypes
    )
    TELEGRAM_AVAILABLE = True
except ImportError:
    print("âŒ pip install python-telegram-bot")
    sys.exit(1)

try:
    import whois
    WHOIS_AVAILABLE = True
except ImportError:
    WHOIS_AVAILABLE = False

try:
    import dns.resolver
    DNS_AVAILABLE = True
except ImportError:
    DNS_AVAILABLE = False

# Secure Logging Setup
class SecureLogger:
    def __init__(self, log_file: str = "hunter_v5.log"):
        self.logger = logging.getLogger("OSINTHunter")
        self.logger.setLevel(logging.INFO)
        
        # File handler
        fh = logging.FileHandler(log_file)
        fh.setFormatter(logging.Formatter('%(asctime)s | %(levelname)s | USER:%(user_id)s | %(message)s'))
        
        # Console handler
        ch = logging.StreamHandler()
        ch.setFormatter(logging.Formatter('%(asctime)s | %(message)s'))
        
        self.logger.addHandler(fh)
        self.logger.addHandler(ch)
        
        # Redaction filter
        class RedactFilter(logging.Filter):
            def filter(self, record):
                msg = str(record.msg)
                msg = re.sub(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', '[IP_HIDDEN]', msg)
                msg = re.sub(r'\+?\d{8,15}', '[PHONE_HIDDEN]', msg)
                record.msg = msg
                return True
        self.logger.addFilter(RedactFilter())

class RateLimiter:
    """Rate limiting Ù…ØªÙ‚Ø¯Ù…"""
    def __init__(self, max_requests: int = MAX_REQUESTS_PER_MINUTE, window: int = 60):
        self.max_requests = max_requests
        self.window = window
        self.requests: Dict[int, deque[datetime]] = defaultdict(deque)
    
    def is_allowed(self, user_id: int) -> Tuple[bool, str]:
        now = datetime.now()
        user_requests = self.requests[user_id]
        
        # Clean old requests
        while user_requests and now - user_requests[0] > timedelta(seconds=self.window):
            user_requests.popleft()
        
        if len(user_requests) >= self.max_requests:
            return False, f"â³ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ ({self.max_requests}/Ø¯Ù‚ÙŠÙ‚Ø©) ÙˆØµÙ„"
        
        user_requests.append(now)
        return True, "âœ…"

@dataclass
class ScanStats:
    total_scans: int = 0
    ip_scans: int = 0
    phone_scans: int = 0
    social_scans: int = 0
    email_scans: int = 0
    ports_found: int = 0

class OSINTHunterV5:
    """ğŸ´â€â˜ ï¸ Ø§Ù„ØµÙŠØ§Ø¯ Ø§Ù„Ù…ØªØ·ÙˆØ± v5.0 - Ø§Ù„ÙƒØ§Ù…Ù„ ÙˆØ§Ù„Ø¢Ù…Ù†"""
    
    def __init__(self):
        if TELEGRAM_BOT_TOKEN == "YOUR_BOT_TOKEN_HERE":
            print("âŒ ØºÙŠÙ‘Ø± TELEGRAM_BOT_TOKEN ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙˆØ¯!")
            sys.exit(1)
            
        self.logger = SecureLogger()
        self.rate_limiter = RateLimiter()
        self.stats = ScanStats()
        self.recent_scans = deque(maxlen=10)
        self.banned_users = set()
        
        # Secure HTTP Session
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'OSINT-Hunter-v5.0/Enterprise (Security-Research)',
            'Accept': 'application/json, text/plain, */*',
            'Accept-Language': 'ar-SA,ar;q=0.9,en;q=0.8'
        })
        
        # Telegram Application
        self.app = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        self._setup_handlers()
        
        self.logger.logger.info("ğŸš€ OSINT HUNTER v5.0 ENTERPRISE Ø¬Ø§Ù‡Ø²!")
    
    # ğŸ”¥ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ… Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ©
    async def dashboard(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        stats_text = f"""
**ğŸ´â€â˜ ï¸ OSINT HUNTER v5.0 ENTERPRISE ğŸ´â€â˜ ï¸**

**ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø­ÙŠØ© ({self.stats.total_scans} Ù…Ø³Ø­ÙŠØ©):**
â”œ **IP:** `{self.stats.ip_scans}`
â”œ **Phone:** `{self.stats.phone_scans}`  
â”œ **Social:** `{self.stats.social_scans}`
â”œ **Email:** `{self.stats.email_scans}`
â”” **Ports:** `{self.stats.ports_found}`

**ğŸ¯ Ø¢Ø®Ø± Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª:**
{chr(10).join(list(self.recent_scans)) or 'Ù„Ø§ ÙŠÙˆØ¬Ø¯'}

**ğŸ• Ø§Ù„ÙˆÙ‚Øª:** `{datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}`
        """
        
        keyboard = [
            [InlineKeyboardButton("ğŸŒ IP PRO", callback_data="ip_pro")],
            [InlineKeyboardButton("ğŸ“± Phone PRO", callback_data="phone_pro")],
            [InlineKeyboardButton("ğŸ‘¥ Social 25+", callback_data="social_pro")],
            [],
            [InlineKeyboardButton("ğŸ›¡ï¸ SHODAN", callback_data="shodan_pro")],
            [InlineKeyboardButton("ğŸ”¥ BULK", callback_data="bulk_pro")],
            [InlineKeyboardButton("âš™ï¸ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª", callback_data="settings")]
        ]
        
        if update.callback_query:
            await update.callback_query.edit_message_text(
                stats_text, parse_mode='Markdown', 
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            await update.message.reply_text(
                stats_text, parse_mode='Markdown', 
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
    
    # ğŸŒ IP Ultimate Recon
    def ultimate_ip_scan(self, ip_address: str) -> str:
        """Ù…Ø³Ø­ IP Ø´Ø§Ù…Ù„ 30+ API + Ports + DNS"""
        self.stats.ip_scans += 1
        self.stats.total_scans += 1
        
        if not self._validate_ip(ip_address):
            return f"**âŒ `{ip_address}` IP ØºÙŠØ± ØµØ§Ù„Ø­**"
        
        result = f"**ğŸŒ IP ULTIMATE: `{ip_address}`** ğŸ´â€â˜ ï¸\n"
        result += "â”" * 55 + "\n"
        
        # Geolocation Ù…Ù† Ù…ØµØ§Ø¯Ø± Ù…ØªØ¹Ø¯Ø¯Ø©
        geo_info = self._get_ip_geolocation(ip_address)
        result += geo_info
        
        # Port Scan Ø³Ø±ÙŠØ¹
        ports_result = self._fast_port_scan(ip_address)
        result += ports_result
        
        # DNS Records
        dns_result = self._dns_lookup(ip_address)
        result += dns_result
        
        # Threat Check
        threat_result = self._threat_check(ip_address)
        result += threat_result
        
        self.recent_scans.append(f"ğŸŒ IP: {ip_address}")
        return result
    
    def _get_ip_geolocation(self, ip: str) -> str:
        """Ø¬Ù„Ø¨ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ù† 10+ API"""
        geo_data = {"country": [], "city": [], "isp": [], "org": [], "asn": []}
        
        def fetch_geo(api_url: str) -> Optional[Dict]:
            try:
                resp = self.session.get(api_url.format(ip=ip), timeout=API_REQUEST_TIMEOUT)
                if resp.status_code == 200:
                    return resp.json()
            except:
                pass
            return None
        
        # Parallel execution
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(fetch_geo, api) for api in IP_GEOLOCATION_APIS[:10]]
            for future in futures:
                data = future.result()
                if data:
                    for key in geo_data:
                        val = data.get(key) or data.get(key.upper())
                        if val:
                            geo_data[key].append(str(val))
        
        # Format results
        result = ""
        for key, values in geo_data.items():
            if values:
                result += f"**{key.title()}:** `{values[0]}` ({len(values)} Ù…ØµØ§Ø¯Ø±)\n"
        return result or "**ğŸ“ Geolocation:** ØºÙŠØ± Ù…ØªÙˆÙØ±\n"
    
    def _fast_port_scan(self, ip: str) -> str:
        """Ù…Ø³Ø­ 25 Ù…ÙŠÙ† Ø³Ø±ÙŠØ¹"""
        open_ports = []
        top_ports = list(COMMON_PORTS.keys())[:25]
        
        def scan_port(port: int) -> bool:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(PORT_SCAN_TIMEOUT)
                result = sock.connect_ex((ip, port)) == 0
                sock.close()
                return result
            except:
                return False
        
        with ThreadPoolExecutor(max_workers=30) as executor:
            futures = {executor.submit(scan_port, port): port for port in top_ports}
            for future in futures:
                if future.result():
                    port = futures[future]
                    service = COMMON_PORTS[port]
                    open_ports.append(f"{service}:{port}")
                    self.stats.ports_found += 1
        
        if open_ports:
            return f"\n**ğŸ”Œ Ù…ÙˆØ§Ù†Ø¦ Ù…ÙØªÙˆØ­Ø© ({len(open_ports)}):** `{', '.join(open_ports)}`"
        return "\n**ğŸ”’ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙˆØ§Ù†Ø¦ Ø¢Ù…Ù†Ø©** âœ…"
    
    # ğŸ“± Phone Scanner
    def phone_scanner(self, phone: str) -> str:
        self.stats.phone_scans += 1
        self.stats.total_scans += 1
        
        try:
            parsed = phonenumbers.parse(phone)
            if not phonenumbers.is_valid_number(parsed):
                return f"**ğŸ“± `{phone}` âŒ ØºÙŠØ± ØµØ§Ù„Ø­**"
            
            result = f"""**ğŸ“± PHONE SCANNER: `{phone}`** ğŸ´â€â˜ ï¸

**ğŸŒ Ø§Ù„Ø¨Ù„Ø¯:** `{geocoder.description_for_number(parsed, "ar")}`
**ğŸ“¡ Ø§Ù„Ù…Ø´ØºÙ„:** `{carrier.name_for_number(parsed, "ar") or 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'}`
**ğŸ“ Ø§Ù„Ù…ÙˆÙ‚Ø¹:** `{geocoder.description_for_number(parsed, "en")}`
**ğŸ• Ø§Ù„Ù…Ù†Ø§Ø·Ù‚ Ø§Ù„Ø²Ù…Ù†ÙŠØ©:** `{', '.join(timezone.time_zones_for_number(parsed))}`
**âœ… Ø§Ù„Ø­Ø§Ù„Ø©:** `{phonenumbers.is_valid_number(parsed)}`"""
            
            self.recent_scans.append(f"ğŸ“± Phone: {phone}")
            return result
        except:
            return f"**ğŸ“± `{phone}` âŒ Ø®Ø·Ø£**"
    
    # ğŸ‘¥ Social Scanner
    async def social_scanner(self, username: str) -> str:
        self.stats.social_scans += 1
        self.stats.total_scans += 1
        
        result = f"**ğŸ‘¥ SOCIAL HUNTER: @{username}** (25+ Platform)\nâ”" * 25 + "\n"
        live_count = 0
        
        async def check_social(platform: str, url: str) -> str:
            try:
                resp = await asyncio.wait_for(
                    self.session.head(url.format(username), timeout=4),
                    timeout=4
                )
                return f"{platform}: {'âœ…' if resp.status_code < 400 else 'âŒ'}"
            except:
                return f"{platform}: âš ï¸"
        
        tasks = [check_social(name, url) for name, url in SOCIAL_PLATFORMS.items()]
        social_results = await asyncio.gather(*tasks)
        
        for platform_result in social_results:
            result += f"{platform_result}\n"
        if not social_results:
            for platform_result in social_results:
             result += f"{platform_result}\n"
            if 'âœ…' in platform_result:
                live_count += 1
        
        result += f"\n**ğŸ“Š Ø§Ù„Ù†ØªÙŠØ¬Ø©:** {live_count}/{len(SOCIAL_PLATFORMS)} Ø­Ø³Ø§Ø¨ Ù†Ø´Ø·"
        self.recent_scans.append(f"ğŸ‘¥ @{username}")
        return result
    
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ù…Ø¯Ø®Ù„Ø§Øª Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ
    async def main_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠ Ù…Ø¹ Ø§Ù„ÙƒØ´Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ"""
        user_id = update.effective_user.id
        target = update.message.text.strip()
        
        self.logger.logger.info("Ø¨Ø¯Ø¡ Ù…Ø¹Ø§Ù„Ø¬Ø© Ù‡Ø¯Ù", extra={'user_id': user_id})
        await update.message.reply_chat_action(action="typing")
        
        # ÙØ­Øµ Rate Limit
        allowed, message = self.rate_limiter.is_allowed(user_id)
        if not allowed:
            await update.message.reply_text(message, parse_mode='Markdown')
            return
        
        # Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…Ø¯Ø®Ù„
        if len(target) > 100 or not target:
            await update.message.reply_text("âŒ **Ù…Ø¯Ø®Ù„ ØºÙŠØ± ØµØ§Ù„Ø­**", parse_mode='Markdown')
            return
        
        # ÙƒØ´Ù ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù†ÙˆØ¹ Ø§Ù„Ù‡Ø¯Ù
        if self._validate_ip(target):
            result = self.ultimate_ip_scan(target)
        elif self._validate_phone(target):
            result = self.phone_scanner(target)
        elif '@' in target and self._validate_email(target):
            result = self.email_whois_scan(target)
        else:
            result = await self.social_scanner(target)
        
        # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ù…Ø¹ Ø£Ø²Ø±Ø§Ø± Ø§Ù„ØªØ­ÙƒÙ…
        keyboard = [
            [InlineKeyboardButton("ğŸ  Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©", callback_data="dashboard")],
            [InlineKeyboardButton("ğŸ”„ Ù‡Ø¯Ù Ø¬Ø¯ÙŠØ¯", callback_data="new_scan")]
        ]
        
        await update.message.reply_text(
            result, parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard),
            disable_web_page_preview=True
        )
    
    # Ø£Ø¯ÙˆØ§Øª Ù…Ø³Ø§Ø¹Ø¯Ø©
    def _validate_ip(self, target: str) -> bool:
        return bool(re.match(r'^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$', target))
    
    def _validate_phone(self, target: str) -> bool:
        cleaned = re.sub(r'[^\d+]', '', target)
        return bool(re.match(r'^\+?\d{8,15}$', cleaned))
    
    def _validate_email(self, target: str) -> bool:
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return bool(re.match(pattern, target))
    
    def _dns_lookup(self, ip: str) -> str:
        """DNS Lookup Ø´Ø§Ù…Ù„"""
        result = ""
        try:
            hostname = socket.gethostbyaddr(ip)[0]
            result += f"\n**ğŸ”„ PTR Record:** `{hostname}`\n"
        except:
            result += "\n**ğŸ”„ PTR:** ØºÙŠØ± Ù…ØªÙˆÙØ±\n"
        
        if DNS_AVAILABLE:
            try:
                resolver = dns.resolver.Resolver()
                resolver.timeout = 2
                
                for rtype in ['A', 'MX', 'NS', 'TXT']:
                    try:
                        answers = resolver.resolve(ip, rtype)
                        records = [str(r).rstrip('.') for r in answers][:2]
                        if records:
                            result += f"**{rtype}:** `{records[0]}`\n"
                    except:
                        continue
            except:
                pass
        return result
    
    def _threat_check(self, ip: str) -> str:
        """ÙØ­Øµ Ø§Ù„ØªÙ‡Ø¯ÙŠØ¯Ø§Øª"""
        try:
            resp = self.session.get(
                f"https://internetdb.shadowserver.org/api/v1/ip/{ip}",
                timeout=API_REQUEST_TIMEOUT
            )
            if resp.status_code == 200:
                data = resp.json()
                threats = data.get("total", 0)
                if threats > 0:
                    return f"\n**ğŸ›¡ï¸ Threat Score:** âš ï¸ {threats} ØªÙ‡Ø¯ÙŠØ¯Ø§Øª"
        except:
            pass
        return "\n**ğŸ›¡ï¸ Threat Score:** âœ… Ù†Ø¸ÙŠÙ"
    
    def email_whois_scan(self, email: str) -> str:
        """WHOIS Ù„Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ"""
        self.stats.email_scans += 1
        self.stats.total_scans += 1
        
        domain = email.split('@')[1]
        result = f"**âœ‰ï¸ EMAIL WHOIS: `{email}`** ğŸ´â€â˜ ï¸\n"
        
        try:
            if WHOIS_AVAILABLE:
                w = whois.whois(domain)
                result += f"**ğŸ¢ Ø§Ù„Ø´Ø±ÙƒØ©:** `{w.name or 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ'} `\n"
                result += f"**ğŸ“… ØªØ§Ø±ÙŠØ® Ø§Ù„Ø¥Ù†Ø´Ø§Ø¡:** `{getattr(w, 'creation_date', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}`\n"
                result += f"**ğŸ“… Ø§Ù†ØªÙ‡Ø§Ø¡:** `{getattr(w, 'expiration_date', 'ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ')}`\n"
            else:
                result += "**WHOIS:** Ù‚Ù… Ø¨ØªØ«Ø¨ÙŠØª `pip install python-whois`\n"
        except Exception as e:
            result += f"**WHOIS:** ØºÙŠØ± Ù…ØªÙˆÙØ±\n"
        
        # MX Records
        try:
            mx_records = []
            for rdata in dns.resolver.resolve(domain, 'MX'):
                mx_records.append(str(rdata.exchange).rstrip('.'))
            if mx_records:
                result += f"**ğŸ“¨ MX:** `{mx_records[0]}`\n"
        except:
            pass
        
        self.recent_scans.append(f"âœ‰ï¸ {email}")
        return result
    
    # Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        query = update.callback_query
        await query.answer()
        
        query_data = query.data
        user_id = update.effective_user.id
        
        # Admin Check
        is_admin = user_id in ADMIN_USER_IDS
        
        handlers = {
            "dashboard": self.dashboard,
            "ip_pro": self._ip_prompt,
            "phone_pro": self._phone_prompt,
            "social_pro": self._social_prompt,
            "new_scan": self._new_scan_prompt,
            "stats": self._stats_command,
            "admin": self._admin_panel if is_admin else None
        }
        
        if query_data in handlers and handlers[query_data]:
            await handlers[query_data](update, context)
    
    async def _ip_prompt(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        await update.callback_query.edit_message_text(
            "**ğŸŒ Ø£Ø±Ø³Ù„ IP:**\n`8.8.8.8` `1.1.1.1` `203.0.113.1`\n\n"
            "**Ù…Ø«Ø§Ù„:** `185.13.45.67`",
            parse_mode='Markdown'
        )
    
    async def _phone_prompt(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        await update.callback_query.edit_message_text(
            "**ğŸ“± Ø£Ø±Ø³Ù„ Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ:**\n`+966501234567` `966501234567`\n\n"
            "**Ù…Ø«Ø§Ù„:** `+966555555555`",
            parse_mode='Markdown'
        )
    
    async def _social_prompt(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        await update.callback_query.edit_message_text(
            "**ğŸ‘¥ Ø£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:**\n`@username` `username`\n\n"
            "**Ù…Ø«Ø§Ù„:** `elonmusk`",
            parse_mode='Markdown'
        )
    
    async def _new_scan_prompt(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        await update.callback_query.edit_message_text(
            "**ğŸ¯ Ø£Ø±Ø³Ù„ Ø§Ù„Ù‡Ø¯Ù (ØªÙ„Ù‚Ø§Ø¦ÙŠ):** IP | Phone | Email | Username",
            parse_mode='Markdown'
        )
    
    async def _stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        stats_msg = f"""
**ğŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ù…ÙØµÙ„Ø©:**
â€¢ **Ø¥Ø¬Ù…Ø§Ù„ÙŠ:** `{self.stats.total_scans}`
â€¢ **IP:** `{self.stats.ip_scans}`
â€¢ **Phone:** `{self.stats.phone_scans}`
â€¢ **Social:** `{self.stats.social_scans}`
â€¢ **Email:** `{self.stats.email_scans}`
â€¢ **Ports:** `{self.stats.ports_found}`
        """
        await update.callback_query.edit_message_text(stats_msg, parse_mode='Markdown')
    
    async def _admin_panel(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        keyboard = [
            [InlineKeyboardButton("ğŸ“Š Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª", callback_data="stats")],
            [InlineKeyboardButton("ğŸ”„ Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†", callback_data="reset_stats")],
            [InlineKeyboardButton("ğŸš« Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…", callback_data="ban_user")]
        ]
        await update.callback_query.edit_message_text(
            "**ğŸ”§ Ù„ÙˆØ­Ø© Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©**", 
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    # Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬Ø§Øª
    def _setup_handlers(self) -> None:
        self.app.add_handler(CommandHandler("start", self.start_handler))
        self.app.add_handler(CommandHandler("stats", self.stats_handler))
        self.app.add_handler(CommandHandler("dashboard", self.dashboard))
        
        self.app.add_handler(CallbackQueryHandler(self.button_handler))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.main_handler))
    
    async def start_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"""
        keyboard = [[InlineKeyboardButton("ğŸš€ Ø§Ø¨Ø¯Ø£ Ø§Ù„ØµÙŠØ¯", callback_data="dashboard")]]
        welcome = """
**ğŸ´â€â˜ ï¸ OSINT HUNTER v5.0 ENTERPRISE ğŸ´â€â˜ ï¸**

**ğŸ”¥ Ø£Ù‚ÙˆÙ‰ Ø£Ø¯Ø§Ø© OSINT ÙÙŠ Ø§Ù„Ø¹Ø§Ù„Ù… Ø§Ù„Ø¹Ø±Ø¨ÙŠ ğŸ”¥**
âœ… 30+ API Ù„ØªØ­Ù„ÙŠÙ„ IP
âœ… 25+ Ù…Ù†ØµØ© ØªÙˆØ§ØµÙ„ Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ
âœ… Port Scanner Ø³Ø±ÙŠØ¹
âœ… Rate Limiting Ø£Ù…Ø§Ù†
âœ… Admin Panel ÙƒØ§Ù…Ù„

**Ø§Ø¶ØºØ· Ø§Ù„Ø²Ø± Ù„Ø¨Ø¯Ø¡ Ø§Ù„ØµÙŠØ¯ Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠ!**
        """
        await update.message.reply_text(
            welcome, parse_mode='Markdown',
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    async def stats_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        await self._stats_command(update, context)
    
    def run(self) -> None:
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
        print("ğŸ´â€â˜ ï¸ OSINT HUNTER v5.0 ENTERPRISE")
        print("ğŸ”¥ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…ÙŠØ²Ø§Øª Ø¬Ø§Ù‡Ø²Ø©!")
        print("ğŸ“Š Logs: hunter_v5.log")
        print("âš™ï¸ ØºÙŠÙ‘Ø± Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª ÙÙŠ Ø£Ø¹Ù„Ù‰ Ø§Ù„ÙƒÙˆØ¯")
        print("-" * 50)
        
        self.app.run_polling(drop_pending_updates=True)

# ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬
if __name__ == "__main__":
    print("ğŸ” ÙØ­Øµ Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª...")
    print("âœ… python-telegram-bot")
    print("âœ… phonenumbers")
    print(f"ğŸ”§ WHOIS: {'âœ…' if WHOIS_AVAILABLE else 'âŒ pip install python-whois'}")
    print(f"ğŸ”§ DNS: {'âœ…' if DNS_AVAILABLE else 'âŒ pip install dnspython'}")
    print("-" * 50)
    
    try:
        bot = OSINTHunterV5()
        bot.run()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ ØªÙˆÙ‚Ù Ø¢Ù…Ù†")
    except Exception as error:
        print(f"ğŸ’¥ Ø®Ø·Ø£: {error}")
        print("ğŸ’¡ ØªØ£ÙƒØ¯ Ù…Ù† TELEGRAM_BOT_TOKEN")
        sys.exit(1)